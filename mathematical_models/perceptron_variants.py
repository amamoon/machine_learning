# -*- coding: utf-8 -*-
"""FinalQ3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-XVQEApkq_E_HjwS4MWRTqj5pP2YMDGW
"""

import numpy as np
import pandas as pd # not really needed, only for preference
import matplotlib.pyplot as plt

x = pd.read_csv("Q3X.csv")
y = pd.read_csv("Q3y.csv")
x = np.array(x)
y = np.array(y)

print(y)

# from lab
def plot_perceptron(ax, X, y, w):
    pos_points = X[np.where(y==1)[0]]
    neg_points = X[np.where(y==-1)[0]]
    ax.scatter(pos_points[:, 1], pos_points[:, 2], color='blue')
    ax.scatter(neg_points[:, 1], neg_points[:, 2], color='red')
    xx = np.linspace(-6,6)
    yy = -w[0]/w[2] - w[1]/w[2] * xx
    ax.plot(xx, yy, color='orange')
    
    ratio = (w[2]/w[1] + w[1]/w[2])
    xpt = (-1*w[0] / w[2]) * 1/ratio
    ypt = (-1*w[0] / w[1]) * 1/ratio
    
    ax.arrow(xpt, ypt, w[1], w[2], head_width=0.2, color='orange')
    ax.axis('equal')

# Change this
def perceptron(X, y, max_iter=100):
    np.random.seed(1)
    # your code here 
    # input x y
    # init w
    w = np.zeros(shape=X.shape[1])
    # for t = 1, ... , max_iter
    nmb_iter = 0
    eta = 1
    np.seterr('raise')
    m = 0
    while m < max_iter:
        missed = []
        miss = 0

        nmb_iter += 1
        for i in range(X.shape[0]):
            yXw = (y[i] * X[i]) @ w.T
            if yXw <= 0:
                missed.append(i)
        
        #print(m)
        if len(missed) > 0:
            i = np.random.choice(missed)        # pick idx randomly
            w += y[i]*X[i]
        elif len(missed) == 0:
            break
        m += 1
        
    return w, nmb_iter

w, nmb_iter = perceptron(x, y, 100)
print(w)
fig, ax = plt.subplots()
x = np.array(x)
y = np.array(y)
plot_perceptron(ax, x, y, w)       # from neural learning lab

ax.set_title(f"w={w},    iterations={nmb_iter}")
plt.savefig("name.png", dpi=300)      # if you want to save your plot as a png
plt.show()

def dual_perceptron_new(X, y, eta=1):
    np.random.seed(1)
    a = np.zeros(shape=X.shape[0])
    w = np.zeros(shape=X.shape[0])          # randomly init weight vector for visualisation only
    nmb_iter = 0
    converge= False
    for i in range(100):
        while converge == False:
            nmb_iter+=1
            missed = []
            converge = True
            w_sum = 0
            # for each misclassified 
            for i in range(X.shape[0]):
                sum = 0
                for j in range(X.shape[0]):
                    sum += a[j]*y[j]*np.dot(X[i],X[j])
                yw = y[i] * sum
                w_sum += a[i]*y[i]*X[i]
                if yw <= 0:
                    missed.append(i)
                    converge = False
            if len(missed) > 0:
                i = np.random.choice(missed)
                converge = False
                a[i] += 1
            else:
                break
        w = w_sum
    return w, a, nmb_iter


w, a, nmb_iter = dual_perceptron_new(x, y, 100)
fig, ax = plt.subplots()
x = np.array(x)
y = np.array(y)
plot_perceptron(ax, x, y, w)       # from neural learning lab
ax.set_title(f"w={w},    iterations={nmb_iter}")
plt.savefig("name.png", dpi=300)      # if you want to save your plot as a png
plt.show()

print(a)

xb = np.array(range(x.shape[0]))
a = np.array(a)
fig, ax = plt.subplots()
ax.scatter(x=xb, y=a)
ax.set_xlabel("i = 1,...,n")
ax.set_ylabel(r"$\alpha_i$")
ax.set_title("Points vs Weight Coefs")
plt.show()

def rperceptron(X, y, max_iter, r):
    np.random.seed(1)
    # your code here 
    # input x y
    # init w
    w = np.zeros(shape=X.shape[1])
    I = np.zeros(shape=X.shape[0])
    # for t = 1, ... , max_iter
    max_iter=100
    nmb_iter = 0
    eta = 1
    np.seterr('raise')
    m = 0
    prev_update = []
    while m < max_iter:
        missed = []
        miss = 0
        nmb_iter += 1
        for i in range(X.shape[0]):
            yXw = ((y[i] * X[i]) @ w.T) + (I[i]*r)
            if yXw <= 0:
                missed.append(i)

        if len(missed) > 0:
            i = np.random.choice(missed)
            w += y[i]*X[i]
            I[i] = 1
        elif len(missed) == 0:
            break
        m += 1
        
    return w, nmb_iter

w, nmb_iter = rperceptron(x, y, 100, 2)
print(w)
fig, ax = plt.subplots()
x = np.array(x)
y = np.array(y)
plot_perceptron(ax, x, y, w)       # from neural learning lab
ax.set_title(f"w={w},    iterations={nmb_iter}")
plt.ylim(-6, 8)
plt.savefig("name.png", dpi=300)      # if you want to save your plot as a png
plt.show()

def dual_rperceptron(X, y, max_iter, r):
    np.random.seed(1)
    # your code here 
    # input x y
    # init w
    w = np.zeros(shape=X.shape[1])
    I = np.zeros(shape=X.shape[0])
    # for t = 1, ... , max_iter
    max_iter=100
    nmb_iter = 0
    eta = 1
    np.seterr('raise')
    m = 0
    prev_update = []
    while m < max_iter:
        convereged = False
        while converged == False:
            converged = True
            missed = []
            miss = 0
            nmb_iter += 1
            for i in range(X.shape[0]):
                yXw = ((y[i] * X[i]) @ w.T) + (I[i]*r)
                if yXw <= 0:
                    missed.append(i)

            if len(missed) > 0:
                i = np.random.choice(missed)
                w += y[i]*X[i]
                I[i] = 1
            elif len(missed) == 0:
                break
        m += 1
        
    return w, nmb_iter

w, nmb_iter = rperceptron(x, y, 100, 2)
print(w)
fig, ax = plt.subplots()
x = np.array(x)
y = np.array(y)
plot_perceptron(ax, x, y, w)       # from neural learning lab
ax.set_title(f"w={w},    iterations={nmb_iter}")
plt.ylim(-6, 8)
plt.savefig("name.png", dpi=300)      # if you want to save your plot as a png
plt.show()
